#' @title Apply the fundamental attribution calculations to a portfolio
#' 
#' @description Calculate the fundamental attribution results for the supplied data. The data is expected to be the output from a `fa_load_*` function. Portfolio returns are separated into growth, multiple, activity and intra-period components. Portfolio returns and yields implied by the underlying assets are also calculated.
#' 
#' @param .dt A data.table generated by a `fa_load_*` function. Or, an equivalent data.table/data.frame/tibble containing the returns, yields and starting weights for each asset in the portfolio during each measurement period.
#' @param index_col The character name of the column containing the time index (eg period end date) for each measurement period.
#' @param id_col The character name of the column containing the identifier of each asset in the portfolio.
#' @param group_cols A character vector of columns names identifying each different portfolio and fundamental metric. This is used to group portfolios allowing multiple portfolios and fundamental metrics to be analysed together.
#' @param na_rm_start_weights Remove rows where start_weights are NA. Defaults to FALSE.
#' 
#' @return A data.table of attribution results.
#' 
#' @export
fa_attribution <- function(.dt, index_col = 'index', id_col = 'id', group_cols = c('metric_name','group_id','series_name','series_type'), na_rm_start_weights = F){
  
  temp <- data.table::as.data.table(.dt)
  
  temp[, 'returns_1p' := 1 + returns]
  temp[, 'start_yield' := data.table::shift(x = metric_to_price, n = 1L, fill = NA, type = 'lag'), by = c(id_col, group_cols)]
  temp[, 'end_yield' := metric_to_price]
  temp[, 'end_weight' := data.table::shift(x = start_weight, n = 1L, fill = NA, type = 'lead'), by = c(id_col, group_cols)]
  
  temp[, 'end_weight_temp' := (start_weight * returns_1p) / sum(start_weight * returns_1p, na.rm = T), by = c(index_col, group_cols)]
  
  temp[is.na(end_weight), 'end_weight' := end_weight_temp][, 'end_weight_temp' := NULL]
  
  if (na_rm_start_weights) temp <- temp[!is.na(start_weight)]
  
  temp <- temp[,.(
    'implied_return' = 1 + sum(returns_ctb, na.rm = T),
    'implied_yield' = sum(end_yield * end_weight, na.rm = T),
    'growth' = sum(start_weight * returns_1p * end_yield, na.rm = T) / sum(start_weight * start_yield, na.rm = T),
    'activity' = (sum(start_weight * returns_1p, na.rm = T) * sum(end_weight * end_yield, na.rm = T)) / sum(start_weight * returns_1p * end_yield, na.rm = T),
    'multiple' = sum(start_weight * start_yield, na.rm = T) / sum(end_weight * end_yield, na.rm = T)
  ),
  by = c(index_col, group_cols)
  ]
  
  temp[,c('implied_return','growth','activity','multiple') := list(log(implied_return),
                                                                   log(growth),
                                                                   log(activity),
                                                                   log(multiple))]
  
  for (j in c('implied_return','growth','activity','multiple')) {
    data.table::set(temp, which(is.nan(temp[[j]]) | is.infinite(temp[[j]])), j, NA)
  }
  
  temp[,'intra_period' := implied_return - (growth + activity + multiple)]
  
  return(temp)
  
}
